# Simple Socket Communication with Protocol Buffers

## Purpose
This project demonstrates simple client-server communication using Java's `SocketServer` and `Socket` classes. It utilizes a custom protocol defined with Protocol Buffers (protobuf). The client reads a JSON file, creates a protobuf object, sends it to the server, and receives the calculated result. The server responds with a protobuf message containing the result.

For protocol details, please refer to the `.proto` file located in the default `src/main/proto` directory. The Gradle build system is set up to compile the protobuf files.

## How to Run
1. Compile the protobuf file:
   ```sh
   gradle generateProto

2. Run the server:
   ```sh
   gradle runServer

3. Run the client:
   ```sh
   gradle runClient or gradle runClient -Pport=9099 -Phost='localhost'


## Protocol

*Note:* **CL == client, SV == server**

## Logging In

1. **Logging In (Client Interaction):**
   - The client initiates the login process by sending a request with their name.
     - Request Type: `NAME`
     - Required Fields: `name`

2. **Logging In (Server Interaction):**
   - The server responds to the client's login request with a greeting message.
     - Response Type: `HELLO`
     - Required Fields: `message` (a greeting message to the client)

## Viewing Leaderboard

1. **Viewing Leaderboard (Client Interaction):**
   - The client can request the leaderboard to view past players' scores.
     - Request Type: `LEADERBOARD`
     - Required Fields: None

2. **Viewing Leaderboard (Server Interaction):**
   - The server responds with a list of past players and their scores.
     - Response Type: `LEADERBOARD`
     - Required Fields: `leaderboard` (a repeated field including everyone on the leaderboard)

## Playing the Game

1. **Playing the Game (Client Interaction):**
   - The client initiates the game by requesting a new game to be started or joined.
     - Request Type: `NEW`
     - Required Fields: None

2. **Playing the Game (Server Interaction - Starting a New Game):**
   - The server responds to the client's request, specifying if the game is joined or started.
     - Response Type: `TASK`
     - Required Fields: `image`, `task`

3. **Playing the Game (Client Interaction - Sending an Answer):**
   - While in the game, the client can send an answer to the server.
     - Request Type: `ANSWER`
     - Required Fields: `answer`

4. **Playing the Game (Server Interaction - Game Not Yet Won):**
   - If the game is not yet won, the server replies with another task.
     - Response Type: `TASK`
     - Required Fields: `image`, `task`, `eval` (where `eval` is either `true` or `false`).
       - If `eval` is `false`, the task will be the same as the previous one.

5. **Playing the Game (Server Interaction - Game Won):**
   - If the game is won, the server sends the current finished image and a message indicating the game has been won.
     - Response Type: `WON`
     - Required Fields: `image`, `message` (a winning comment).

## Quitting the Game

1. **Quitting the Game (Client Interaction):**
   - The client can quit the game by sending a request.
     - Request Type: `QUIT`
     - Required Fields: None

2. **Quitting the Game (Server Interaction):**
   - The server responds with a message including a goodbye message.
     - Response Type: `BYE`
     - Required Fields: `message` (a goodbye message).

## Handling Errors

- Errors can be generated by malformed or unexpected requests. The client is responsible for keeping track of the state to continue.

Error Response (Server Interaction):
- Response Type: `ERROR`
- Required Fields: `message` (description of the error), `type` (error type).
   - Error Types:
     - `1` - Required field missing (the message should name the missing field).
     - `2` - Request not supported (the message should name the unsupported request).
     - `0` - Any other errors (in this case, the message will just be displayed).

## How to Work with the Program

To work with the program, follow these general steps:

1. Start the server on a specified port using the `runServer` Gradle task.
2. Start the client and connect to the server by providing the server's hostname and port using the `runClient` Gradle task.
3. Follow the on-screen instructions to log in, view the leaderboard, start or join a game, answer tasks, and quit the game.
4. Pay attention to error messages from the server and handle them accordingly.

The client and server components interact according to the defined protocol, allowing players to participate in the game, view scores, and enjoy the gaming experience.

Make sure you have the required dependencies installed and the Gradle tasks configured as mentioned in the provided `build.gradle` file. You can customize the client's inputs and play the game based on your interactions with the server.


## Server Requirements:

**Handle Client Login:**
- The server must accept client connections.
- When a client connects, it should request the client's name.
- The server must respond to the name request with a greeting message.

**Provide Leaderboard:**
- The server should support the client's request to view the leaderboard.
- It should respond with the list of past players and their scores.

**Start or Join Game:**
- The server must handle the client's request to start or join a new game.
- It should specify if the game is joined or started and provide an initial task.

**Gameplay:**
- While in a game, the server must accept the client's answers to tasks.
- It should validate the answers and update the game state accordingly.
- The server should continue sending new tasks until the game is won or the client quits.

**Game Won Scenario:**
- When a game is won, the server should send the current finished image and a winning message to the client.

**Quit Game:**
- The server must allow clients to quit the game.
- It should send a goodbye message to the client.

**Error Handling:**
- The server should be able to generate error responses for malformed or unsupported requests.
- Error types should be correctly identified and included in the error responses.
- The server should send error messages when required fields are missing or unsupported requests are received.

**Leaderboard Storage:**
- The server should maintain a leaderboard that records players' names, wins, and logins.
- The leaderboard data should be persisted to a file.

## Client Requirements:

**Connect to Server:**
- The client should be able to connect to the server by specifying the server's hostname and port.

**Provide Name:**
- The client must provide its name upon login.
- It should send a request to the server containing its name.
- The client should handle responses from the server, including error responses.

**View Leaderboard:**
- The client should be able to request and view the leaderboard.
- It should display the list of past players and their scores.

**Start or Join Game:**
- The client should be able to request a new game to be started or joined.
- It should handle the server's responses for game initiation.
- The client should display the initial task and image.

**Gameplay:**
- While in a game, the client should be able to send answers to the server.
- The client should handle the server's responses to validate answers and proceed with the game.
- It should continue to answer tasks until the game is won or the client quits.

**Game Won Scenario:**
- When a game is won, the client should display the finished image and the winning message.

**Quit Game:**
- The client should be able to quit the game.
- It should display the server's goodbye message upon quitting.

**Error Handling:**
- The client should correctly handle error responses from the server.
- It should display error messages when required fields are missing or unsupported requests are received.

**Leaderboard Interaction:**
- The client should support interactions with the leaderboard and display the list of past players and their scores.

**Maintain Game State:**
- The client should maintain the game state and handle user interactions throughout the gameplay.

## General Requirements:

**Dependencies:**
- Ensure that the required dependencies for JSON and Protocol Buffers are correctly configured in the project.

**Gradle Tasks:**
- Verify that the Gradle tasks to run the client and server components are configured correctly and can accept custom inputs.

**Persistence:**
- Ensure that the server can persist leaderboard data to a file, allowing data to be saved and loaded between server restarts.

**Documentation:**
- Provide clear documentation, such as a README, explaining how to interact with and configure the client and server components.

**Error Handling:**
- Properly handle errors and edge cases in both the client and server components to ensure a robust user experience.

By fulfilling these requirements, you should have a working client-server program that adheres to the defined protocol, allowing users to log in, view the leaderboard, play games, and handle various interactions and errors.
